<html lang="de"><head>
  <meta charset="UTF-8">
  <title>Mathe liebsch</title>
  <link rel="stylesheet" href="style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>
<a href="elefant.html">
 <img class="logo" src="png/Logo.png">
</a>
<canvas id="game" width="725" height="725"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const tileCanvas = document.createElement('canvas');
const tileCtx = tileCanvas.getContext('2d');

const images = {
  elefant: new Image(),
  cookie: new Image(),
  schnecke: new Image(),
  huhn: new Image(),
  mnf: new Image(),
  traube: new Image()
};

images.elefant.src = "png/Elefant.png";
images.cookie.src = "png/Cookie.png";
images.schnecke.src = "png/Schnecke.png";
images.huhn.src = "png/Huhn.png";
images.mnf.src = "png/Mitternachtsformel.png";
images.traube.src = "png/Traube.png";

const player = {
  size: 100,
  facing: -1,
  speed: 4.2,
  minSpeed: 0
};

const world = {
  offsetX: 0,
  offsetY: 0,
  gridSize: 42,
  tileSize: 840
};

let liebe = 42;
let isMoving = false;
let movementDirectionX = 0;
let movementDirectionY = 0;

let counter = 0;
let counterStarted = false;
let counterInterval;

let darkBackground = false;

function preRenderGrid() {
  tileCanvas.width = world.tileSize;
  tileCanvas.height = world.tileSize;

  const s = world.gridSize;

  for (let x = 0; x < world.tileSize / s; x++) {
    for (let y = 0; y < world.tileSize / s; y++) {
      const isSpecial = (Math.abs(x * 73856093 ^ y * 19349663) % 42 === 0);
      if (isSpecial) {
        tileCtx.fillStyle = darkBackground ? "#404040" : "#808080";
        tileCtx.fillRect(x * s, y * s, s, s);
      }
    }
  }
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  preRenderGrid();
}
window.addEventListener("resize", resize);
resize();

setInterval(() => {
  darkBackground = !darkBackground;
  preRenderGrid();
}, 48000);

function setDirectionFromInput(x, y) {
  const dx = x - canvas.width / 2;
  const dy = y - canvas.height / 2;
  const angle = Math.atan2(dy, dx);
  movementDirectionX = Math.cos(angle);
  movementDirectionY = Math.sin(angle);
  player.facing = movementDirectionX < 0 ? 1 : -1;
  isMoving = true;
}

const keys = { w: false, s: false, a: false, d: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

function setDirectionFromKeys() {
  let dx = 0;
  let dy = 0;

  if (keys.w || keys.ArrowUp) dy -= 1;
  if (keys.s || keys.ArrowDown) dy += 1;
  if (keys.a || keys.ArrowLeft) dx -= 1;
  if (keys.d || keys.ArrowRight) dx += 1;

  if (dx !== 0 || dy !== 0) {
    const angle = Math.atan2(dy, dx);
    movementDirectionX = Math.cos(angle);
    movementDirectionY = Math.sin(angle);
    player.facing = movementDirectionX < 0 ? 1 : -1;
    isMoving = true;
  }
}

const handleTouch = e => {
  if (!counterStarted) startCounter();
  if (e.type === "click") {
    setDirectionFromInput(e.pageX, e.pageY);
  }
  else {
    const t = e.touches[0];
    e.preventDefault();
    setDirectionFromInput(t.pageX, t.pageY);
  }
};

const handleKey = e => {
  if (!counterStarted) startCounter();
  e.preventDefault();
  const isDown = e.type === "keydown";
  if (e.key in keys) {
    keys[e.key] = isDown;
  } else if (e.key.toLowerCase() in keys) {
    keys[e.key.toLowerCase()] = isDown;
  }
  setDirectionFromKeys();
};

canvas.addEventListener("click", handleTouch);
canvas.addEventListener("touchstart", handleTouch, { passive: false });
canvas.addEventListener("touchmove", handleTouch, { passive: false });

window.addEventListener("keydown", handleKey);
window.addEventListener("keyup", handleKey);

canvas.addEventListener("contextmenu", e => e.preventDefault());

const objects = [];
const WORLD_RANGE = 100000;
const INITIAL_OBJECTS = 15000;

function spawnObjects() {
  for (let i = 0; i < INITIAL_OBJECTS; i++) {
    const r = Math.random();
    let img;
    if (r > 0.99) img = images.huhn;  
    else if (r > 0.75) img = images.cookie;
    else if (r > 0.5) img = images.traube;
	else if (r > 0.01) img = images.schnecke;
    else img = images.mnf;

    let w = 42;
    let h = 42;

    if (img === images.mnf) {
      w = 168;
      h = 84;
    }
	else if (img === images.huhn){
      w = 84;
      h = 84;	  
	}

    objects.push({
      x: Math.random() * WORLD_RANGE - WORLD_RANGE / 2,
      y: Math.random() * WORLD_RANGE - WORLD_RANGE / 2,
      w: w,
      h: h,
      image: img
    });
  }
}
spawnObjects();

function update() {
  if (isMoving && player.speed > 0) {
    world.offsetX -= movementDirectionX * player.speed;
    world.offsetY -= movementDirectionY * player.speed;
  }
  checkCollisions();
}

function checkCollisions() {
  for (let i = objects.length - 1; i >= 0; i--) {
    const o = objects[i];
    const r = Math.max(o.w, o.h) / 2;
    if (
      Math.abs(o.x + world.offsetX) < (r + player.size / 2) &&
      Math.abs(o.y + world.offsetY) < (r + player.size / 2)
    ) {
      objects.splice(i, 1);
      if (o.image === images.cookie) {
        player.size += 14;
        player.speed = player.speed * 0.42;
      } else if (o.image === images.schnecke) {
        player.speed += 1.42;
        movementDirectionX *= -1;
        movementDirectionY *= -1;
      } else if (o.image === images.huhn) {
        player.speed = player.speed * 1.42;
        player.size += 42;
	  } else if (o.image === images.traube) {
        player.size += 1; 
      } else if (o.image === images.mnf) {
        liebe += 42;
      } else {
        liebe += 10;
      }
    }
  }
}

function drawGrid() {
  const s = world.tileSize;

  const shiftX = (world.offsetX % s);
  const shiftY = (world.offsetY % s);

  const startX = Math.floor((canvas.width / 2 + shiftX) % s) - s;
  const startY = Math.floor((canvas.height / 2 + shiftY) % s) - s;

  for (let x = startX; x < canvas.width; x += s) {
    for (let y = startY; y < canvas.height; y += s) {
      ctx.drawImage(tileCanvas, x, y);
    }
  }
}

function drawObjects() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  for (const o of objects) {
    if (!o.image.complete) continue;
    const x = centerX + o.x + world.offsetX;
    const y = centerY + o.y + world.offsetY;
    if (x + o.w < 0 || x - o.w > canvas.width || y + o.h < 0 || y - o.h > canvas.height) continue;
    ctx.drawImage(o.image, x - o.w / 2, y - o.h / 2, o.w, o.h);
  }
}

function drawPlayer() {
  if (!images.elefant.complete) return;
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(player.facing, 1);
  ctx.drawImage(images.elefant, -player.size / 2, -player.size / 2, player.size, player.size);
  ctx.restore();
}

function startCounter() {
  if (counterStarted) return;
  counterStarted = true;
  counterInterval = setInterval(() => {
    counter++;
    if (player.size > 58 && liebe > 0) {
      player.size -= 1;
      liebe -= .2;
    } else {
      player.size = 58;
      clearInterval(counterInterval);
      alert("Punkte: " + counter);
      window.location.href = "elefant.html";
    }
  }, 1000);
}

function drawCounter() {
  ctx.font = "1rem 'Latin Modern Mono', monospace";
  ctx.fillStyle = darkBackground ? "#ffffff" : "#000000";
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  const x = canvas.width - 42;
  const y = canvas.height - 42;
  const h = 22;
  ctx.fillText("Liebe: " + liebe.toFixed(0), x, y-h);
  ctx.fillText("Leben: " + (player.size - 58), x, y - 2 * h);
  ctx.fillText("Speed: " + (player.speed * 10).toFixed(0), x, y);
  ctx.fillText("Punkte: " + counter, x, 42);
}

function render() {
  ctx.fillStyle = darkBackground ? "#000000" : "#ffffff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  drawObjects();
  drawPlayer();
  drawCounter();
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

loop();
</script>


<protonpass-root-6f34 data-protonpass-role="root" data-protonpass-theme="os"></protonpass-root-6f34></body></html>